<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IDS peak API: Mainpage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="vendorlogo1_Wx56-32_ids.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IDS peak API
   &#160;<span id="projectnumber">v1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Mainpage </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Intro"></a>
Introduction</h1>
<p>The IDS peak API is a library that unites GenTL and GenApi. In some places, it also introduces some extra functionality. The purpose of this extra functionality is to increase the usability and comfort of the standard GenAPI.</p>
<h2><a class="anchor" id="IntroGenAPI"></a>
GenAPI &amp; GenTL Wrapper</h2>
<p>The classes in the <a class="el" href="namespacepeak_1_1core.html">core</a> namespace are mostly a tight wrapper around the GenAPI and GenTL. It provides some convenience by automatic resource cleanup (RAII), but mostly it reflects the hierarchical structure of the GenTL:</p>
<ul>
<li><em>Each <a class="el" href="classpeak_1_1core_1_1_producer_library.html">ProducerLibrary</a> represents one *.cti and contains exactly one System (not part of GenTL).</em></li>
<li>Each <a class="el" href="classpeak_1_1core_1_1_system.html">System</a> contains 0 or more Interfaces.</li>
<li>Each <a class="el" href="classpeak_1_1core_1_1_interface.html">Interface</a> represents one physical interface in the system (i.e. one network interface card) and contains 0 or more Devices.</li>
<li>Each <a class="el" href="classpeak_1_1core_1_1_device.html">Device</a> represents the GenTL Producersâ€™ proxy for one physical RemoteDevice (i.e. a camera) and contains 0 or more DataStreams.</li>
<li>Each <a class="el" href="classpeak_1_1core_1_1_data_stream.html">DataStream</a> represents a single (image) data stream. 0 or more Buffers can be assigned to each DataStream.</li>
<li>Each <a class="el" href="classpeak_1_1core_1_1_buffer.html">Buffer</a> represents a single, separate memory buffer from the DataStream.</li>
</ul>
<p>Each module can list the <a href="#CorePrinciplesDescriptors">Descriptors</a> of its child modules, which can open the corresponding child module.</p>
<p>Each module needs its parent module to function properly. Therefore, you need to keep the parent modules around until you are done with the child module. When <a href="#UsageDeviceManager">using the DeviceManager</a>, it keeps the ProducerLibrary, System, and Interface modules open until program termination (or until calling <a class="el" href="classpeak_1_1_device_manager.html#a2d78bad81799cbd46c9def0f73832753">DeviceManager::Reset()</a>).</p>
<h2><a class="anchor" id="IntroConvenience"></a>
Convenience Layer</h2>
<p>The main <a class="el" href="namespacepeak.html">peak</a> namespace contains global library functions as well as convenience functionality, which don't exist in GenAPI/GenTL. The convenience functionality simplifies the standard usage of the API, without sacrificing access to the more complex API in the core namespace.</p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<h2><a class="anchor" id="InitCloseLib"></a>
Initialize / Close Library</h2>
<p>Before doing anything else, call <a class="el" href="classpeak_1_1_library.html#a586cf328f43ab2fbfa836d7f726508fc">Library::Initialize()</a>. This will initialize any needed resources. Calling any other function before calling Library::Initialize() will result in a <a class="el" href="classpeak_1_1core_1_1_not_initialized_exception.html">NotInitializedException</a>.</p>
<p>After you are done using the library, call <a class="el" href="classpeak_1_1_library.html#a8a0c9af08e6730cf75927929f5badf6c">Library::Close()</a> before unloading the library. This will clean up any internal resources and stop any running threads.</p>
<dl class="section note"><dt>Note</dt><dd>Calling <a class="el" href="classpeak_1_1_library.html#a8a0c9af08e6730cf75927929f5badf6c">Library::Close()</a> is of particular importance on <em>MS Windows</em> platforms, when using "Run-Time Dynamic Linking", especially when unloading the DLL with FreeLibrary(). Otherwise it is very likely to run into the "Loader-Lock Deadlock Problem" during DLL unloading.</dd></dl>
<h2><a class="anchor" id="UsageHierarchical"></a>
Hierarchical access</h2>
<p>A common way to start programming with the IDS peak API is to enumerate the GenTL producer libraries found in the current environment. This is achieved by calling <a class="el" href="classpeak_1_1core_1_1_environment_inspector.html#aff4e1819c4ade491e01e5c52ab4afd11">EnvironmentInspector::CollectCTIPaths()</a>. Once you have chosen a producer library, you pass its path to the static method <a class="el" href="classpeak_1_1core_1_1_producer_library.html#aedba6fe4c597fbc1045b0d68acc1c569">ProducerLibrary::Open()</a>. From there, you can follow the hierarchical structure of the modules: <a class="el" href="classpeak_1_1core_1_1_producer_library.html">ProducerLibrary</a> -&gt; <a class="el" href="classpeak_1_1core_1_1_system.html">System</a> -&gt; <a class="el" href="classpeak_1_1core_1_1_interface.html">Interface</a> -&gt; <a class="el" href="classpeak_1_1core_1_1_device.html">Device</a> -&gt; <a class="el" href="classpeak_1_1core_1_1_data_stream.html">DataStream</a>. Each Module can list and open its child-modules.</p>
<h2><a class="anchor" id="UsageDeviceManager"></a>
DeviceManager</h2>
<p>If you don't need tight control over when modules are opened and closed, you can also use the <a class="el" href="classpeak_1_1_device_manager.html">DeviceManager</a>. It provides much more convenience by enabling you to enumerate all modules of the available producer libraries with a single function call (<a class="el" href="classpeak_1_1_device_manager.html#a57284efbf38d06e8d1111ad747c16583">DeviceManager::Update()</a>):</p>
<div class="fragment"><div class="line">auto&amp; deviceManager = peak::DeviceManager::Instance();</div><div class="line">deviceManager.Update();</div><div class="line">devices = deviceManager.Devices();</div></div><!-- fragment --><p>To enumerate the <a class="el" href="classpeak_1_1core_1_1_device.html">Devices</a>, the underlying modules (i.e. <a class="el" href="classpeak_1_1core_1_1_producer_library.html">ProducerLibraries</a>, <a class="el" href="classpeak_1_1core_1_1_system.html">Systems</a>, and <a class="el" href="classpeak_1_1core_1_1_interface.html">Interfaces</a>) need to be opened. Since the <a class="el" href="classpeak_1_1_device_manager.html">DeviceManager</a> is a singleton, these modules stay open until program termination or until <a class="el" href="classpeak_1_1_device_manager.html#a2d78bad81799cbd46c9def0f73832753">DeviceManager::Reset()</a> is called.</p>
<h2><a class="anchor" id="Compatibility"></a>
GenTL Compatibility</h2>
<p>*.ctis using <em>GenTL v1.1</em> or higher are supported. When accessing features the *.cti doesn't support, there will be a "not implemented" error. E.g. chunks exist since GenTL v1.3, so trying to access chunks with a GenTL v1.2 *.cti will result in a exception. GenTL v1.0 *.ctis are not supported.</p>
<h1><a class="anchor" id="CorePrinciples"></a>
Core-Principles</h1>
<h2><a class="anchor" id="CorePrinciplesWrapper"></a>
C-API with C++ Wrapper</h2>
<p>The IDS peak API exists as a <a class="el" href="peak__backend_8h.html">plain C-API</a>, so it can be integrated in any programming environment. As a wrapper around the the C-API, there is also a more convenient C++ API. These C++ wrapper classes are implemented as header-only, so there are no compiler incompatibilities.</p>
<h2><a class="anchor" id="CorePrinciplesDescriptors"></a>
Descriptors</h2>
<p>This API uses the concept of descriptors acting as delegates for all openable modules. A descriptor holds information about its module and can open its module.</p>
<h2><a class="anchor" id="CorePrinciplesRAII"></a>
Automatic resource release (RAII)</h2>
<p>This API uses smart pointers to automatically release unused resources. This makes the interaction with the API very intuitive. As an example the descriptors' open functions return a smart pointer holding the opened module. If the user releases the last smart pointer referencing the opened module, the module automatically gets closed and destroyed. The same applies to the event controller returned by <a class="el" href="classpeak_1_1core_1_1_event_supporting_module.html#a1153724c33dc3c1164749dd07c1721d6">EventSupportingModule::EnableEvents()</a>. After releasing the last smart pointer referencing the event controller, the corresponding event type is disabled automatically and the event controller itself is destroyed.</p>
<h1><a class="anchor" id="dynamicLoading"></a>
Static or Dynamic Loading</h1>
<p>By default, this library is linked into the user program, therefore is loaded statically at program start. Instead, it can also be loaded dynamically, when the first library function is called. To use this feature, enable the CMake option <code>PEAK_DYNAMIC_LOADING</code> or set the <code>#define PEAK_DYNAMIC_LOADING</code> before including any of the libraries files.</p>
<h1><a class="anchor" id="dotNet"></a>
C# / .NET</h1>
<p>For Windows, there is also a .NET version of the library.</p>
<p>To use it in a C# project, add a reference to the ids_peak_dotnet.dll to the project.</p>
<p>Before starting your application, make sure that the DLL-Loader can find all required libraries. This means that ids_peak_dotnet.dll, ids_peak_dotnet_interface.dll, ids_peak.dll and all GenICam libraries required by ids_peak.dll are located next to your application binary or that the directory where they are located is added to the DLL-Loader's search directories. To add their directory to the DLL-Loader's search directories, you could simply append their directory to the environment variable 'Path':</p>
<p>PowerShell: </p><div class="fragment"><div class="line">1. $env:Path=&quot;$env:Path;&lt;Installation-Directory-Of-ids_peak.dll&gt;&quot;</div><div class="line">2. $env:Path=&quot;$env:Path;&lt;Installation-Directory-Of-ids_peak_dotnet.dll&gt;&quot;</div><div class="line">3. Start your application</div></div><!-- fragment --><p> CMD: </p><div class="fragment"><div class="line">1. set Path=%Path%;&lt;Installation-Directory-Of-ids_peak.dll&gt;</div><div class="line">2. set Path=%Path%;&lt;Installation-Directory-Of-ids_peak_dotnet.dll&gt;</div><div class="line">3. Start your application</div></div><!-- fragment --><p>The .NET API works much like the C++ API. The same principles, class and method names apply. For example, listing all available devices:</p>
<div class="fragment"><div class="line">using peak; </div><div class="line">try</div><div class="line">{</div><div class="line">    Library.Initialize();</div><div class="line">    var deviceManager = DeviceManager.Instance();</div><div class="line">    deviceManager.Update();</div><div class="line">    var deviceDescriptors = deviceManager.Devices();</div><div class="line">    foreach (var deviceDescriptor in deviceDescriptors)</div><div class="line">    {</div><div class="line">        Console.WriteLine(deviceDescriptor.DisplayName());</div><div class="line">    }</div><div class="line">}</div><div class="line">catch (System.ApplicationException e)</div><div class="line">{</div><div class="line">    Console.WriteLine(&quot;Exception: &quot; + e.Message);</div><div class="line">}</div></div><!-- fragment --><p>There are a few differences between the C++ API and the .NET API. The most important ones are listed here:</p>
<table class="doxtable">
<tr>
<th>C++</th><th>C# / .NET </th></tr>
<tr>
<td><p class="starttd"><b>Deterministic Memory Management</b></p>
<p class="intertd">To close a module (e.g. the Device), you have to release its shared_ptr (out-of-scope, call reset(), set to nullptr), then the module closes immediately.</p>
<div class="fragment"><div class="line">{</div><div class="line">    auto device = deviceDescriptors[0].OpenDevice(DeviceAccessType.Control);</div><div class="line">    // ...</div><div class="line">} // Device closes here</div></div><!-- fragment --> </td><td><p class="starttd"><b>Garbage Collection</b></p>
<p class="endtd">When an object is relased in C#, it won't be closed and deleted immediately. Instead, it will be deleted at some point in the future, when the garbage collection deems it necessary. Often, that's no problem. But if it is, there are 2 options:</p><ul>
<li>Call Dispose() explicitly: <div class="fragment"><div class="line">var device = deviceDescriptors[0].OpenDevice(DeviceAccessType.Control);</div><div class="line">device.Dispose(); // Device closes here</div></div><!-- fragment --></li>
<li>Use using-block: <div class="fragment"><div class="line">using (var device = deviceDescriptors[0].OpenDevice(DeviceAccessType.Control))</div><div class="line">{</div><div class="line">    // ...</div><div class="line">} // Device closes here</div></div><!-- fragment --> </li>
</ul>
</td></tr>
<tr>
<td><b>Callbacks</b> <div class="fragment"><div class="line">device_manager.RegisterDeviceFoundCallback(</div><div class="line">    [](const std::shared_ptr&lt;peak::core::DeviceDescriptor&gt;&amp; newDev)</div><div class="line">    { std::cout &lt;&lt; &quot;Device found: &quot; &lt;&lt; newDev-&gt;DisplayName() &lt;&lt; &#39;\n&#39;; });</div></div><!-- fragment --> </td><td><b>Events + Delegates</b> <div class="fragment"><div class="line">deviceManager.DeviceFoundEvent += (object o, DeviceDescriptor newDev)</div><div class="line">    =&gt; Console.WriteLine(&quot;Device found: {0}&quot;, newDev.DisplayName());</div></div><!-- fragment --> </td></tr>
<tr>
<td><b>Method Default Parameters</b> <div class="fragment"><div class="line">DataStream::StartAcquisition(</div><div class="line">    AcquisitionStartMode mode=AcquisitionStartMode::Default,</div><div class="line">    uint64_t numToAcquire=INFINITE_NUMBER);</div></div><!-- fragment --> </td><td><b>Method Overloads</b> <div class="fragment"><div class="line">DataStream.StartAcquisition(peak.core.AcquisitionStartMode mode, ulong numToAcquire)</div><div class="line">DataStream.StartAcquisition(peak.core.AcquisitionStartMode mode) // with numToAcquire=INFINITE_NUMBER</div><div class="line">DataStream.StartAcquisition() // with mode=Default and numToAcquire=INFINITE_NUMBER</div></div><!-- fragment --> </td></tr>
</table>
<h1><a class="anchor" id="Python"></a>
Python</h1>
<p>To use IDS peak API in Python, there is a separate Python wheel for each supported Python version and CPU architecture. A Python wheel is a package file (with .whl file ending) which can be installed via 'pip', Python's package manager. Just call 'pip install &lt;Path-To-Python-Wheel&gt;' to install your chosen Python wheel.</p>
<p>To finally use IDS peak API in your Python script, just add 'import ids_peak.ids_peak' or 'import ids_peak.ids_peak as some_alias' at the top of your Python script. The latter should be preferred.</p>
<p>The Python API works much like the C++ API. Nearly the same principles, class and method names apply. For example, listing all available devices:</p>
<div class="fragment"><div class="line">import ids_peak.ids_peak as some_alias</div><div class="line"></div><div class="line">try:</div><div class="line">    some_alias.Library.Initialize()</div><div class="line">    device_manager = some_alias.DeviceManager.Instance()</div><div class="line">    device_manager.Update()</div><div class="line">    device_descriptors = device_manager.Devices()</div><div class="line">    for device_descriptor in device_descriptors:</div><div class="line">        print(device_descriptor.DisplayName())</div><div class="line">except ids_peak_alias.Exception as ex:</div><div class="line">    print(&quot;Exception: &quot; + str(ex))</div><div class="line">finally:</div><div class="line">    some_alias.Library.Close()</div></div><!-- fragment --><p>There are only a few differences between the C++ API and the Python API. The most important ones are listed here:</p>
<table class="doxtable">
<tr>
<th>C++</th><th>Python </th></tr>
<tr>
<td><p class="starttd"><b>Deterministic Memory Management</b></p>
<p class="intertd">To close a module (e.g. the Device), you have to release its shared_ptr (out-of-scope, call reset(), set to nullptr), then the module closes immediately.</p>
<div class="fragment"><div class="line">{</div><div class="line">    auto device = deviceDescriptors[0].OpenDevice(DeviceAccessType.Control);</div><div class="line">    // ...</div><div class="line">} // Device gets closed here</div></div><!-- fragment --> </td><td><p class="starttd"><b>Garbage Collection</b></p>
<p class="endtd">When an object is relased in Python, it won't be closed and deleted immediately. Instead, it will be deleted at some point in the future, when the garbage collection deems it necessary. Often, that's no problem. But if it is, you could do the following: </p><div class="fragment"><div class="line">device = deviceDescriptors[0].OpenDevice(some_alias.DeviceAccessType_Control)</div><div class="line">del device # Device gets closed here</div></div><!-- fragment --> </td></tr>
<tr>
<td><b>Enums</b> <div class="fragment"><div class="line">const auto deviceAccessType = DeviceAccessType::Control;</div><div class="line">std::cout &lt;&lt; ToString(deviceAccessType) &lt;&lt; &#39;\n&#39;;</div></div><!-- fragment --> </td><td><b>Enums</b> <div class="fragment"><div class="line">device_access_type = some_alias.DeviceAccessType_Control</div><div class="line">print(some_alias.DeviceAccessTypeEnumEntryToString(device_access_type))</div></div><!-- fragment --> </td></tr>
<tr>
<td><b>Callbacks</b> <div class="fragment"><div class="line">const auto deviceFoundCallbackHandle = deviceManager.RegisterDeviceFoundCallback(</div><div class="line">    [](const std::shared_ptr&lt;peak::core::DeviceDescriptor&gt;&amp; newDev)</div><div class="line">    { std::cout &lt;&lt; &quot;Device found: &quot; &lt;&lt; newDev-&gt;DisplayName() &lt;&lt; &#39;\n&#39;; });</div><div class="line">deviceManager.Update()</div><div class="line">deviceManager.UnregisterDeviceFoundCallback(deviceFoundCallbackHandle);</div></div><!-- fragment --> </td><td><b>Callbacks</b> <div class="fragment"><div class="line">device_found_callback = device_manager.DeviceFoundCallback(</div><div class="line">    lambda new_dev: print(&quot;Device found: {}&quot;, new_dev.DisplayName()))</div><div class="line">device_found_callback_handle = device_manager.RegisterDeviceFoundCallback(device_found_callback)</div><div class="line">device_manager.Update()</div><div class="line">device_manager.UnregisterDeviceFoundCallback(device_found_callback_handle)</div></div><!-- fragment --> </td></tr>
</table>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 18 2021 - &copy; <a style="color: #000000;text-decoration:none;" href="http://www.ids-imaging.com">IDS Imaging Development Systems GmbH</a></li>
  </ul>
</div>
</body>
</html>
